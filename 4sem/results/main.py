# -*- coding: utf-8 -*-
"""laba4.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1awsMRSp2Hnxge_aarEnUGUO1stlLh2Uy
"""

import numpy as np
from PIL import Image
from scipy.signal import convolve2d

def grayscale (image):
    data = image.load()

    result = Image.new('L', image.size)

    new_data = result.load()

    for x in range(image.size[0]):
        for y in range(image.size[1]):
            new_data[x, y] = round(0.3 * data[x,y][0] + 0.59 * data[x,y][1] + 0.11 * data[x,y][2])
    return result

def convolution(image, kernel):
    kernel_height, kernel_width = kernel.shape
    image_height, image_width = image.shape

    result = np.zeros_like(image)

    # Applying convolution for each pixel in the image
    for i in range(image_height):
        for j in range(image_width):
            # Taking a window of size equal to the kernel
            window = image[max(0, i - kernel_height // 2):min(image_height, i + kernel_height // 2 + 1),
                           max(0, j - kernel_width // 2):min(image_width, j + kernel_width // 2 + 1)]

            # Making sure the window and kernel have the same shape before convolution
            if window.shape == kernel.shape:
                result[i, j] = np.sum(window * kernel)

    return result

def robert_operator(image):

    gray_image = grayscale(image)

    gray_array = np.array(gray_image)

    robert_x = np.array([[0, 0, 0], [0, -1, 0], [0, 0, 1]])
    robert_y = np.array([[0, -1, 0], [0, 0, 1], [0, 0, 0]])

    # Gx и Gy
    gradient_x = convolution(gray_array, kernel_x)
    gradient_y = convolution(gray_array, kernel_y)

    gradient = np.abs(gradient_x) + np.abs(gradient_y)

    normalized_gradient_x = (gradient_x / np.max(gradient_x)) * 255
    normalized_gradient_y = (gradient_y / np.max(gradient_y)) * 255
    normalized_gradient = (gradient / np.max(gradient)) * 255

    threshold = 128
    binary_gradient = (normalized_gradient > threshold) * 255


    return gray_image, normalized_gradient_x, normalized_gradient_y, normalized_gradient, binary_gradient

def binarize(gradient, threshold):
    binary_gradient = np.where(gradient > threshold, 255, 0)
    return binary_gradient

if __name__ == "__main__":
    image = Image.open('lisa.png')

    gray_image, gradient_x, gradient_y, gradient, binary_gradient = robert_operator(image)

    # Сохранение изображений
    gray_image.save('lisa_gray_image.png')
    Image.fromarray(gradient_x.astype(np.uint8)).save('lisa_gradient_x.png')
    Image.fromarray(gradient_y.astype(np.uint8)).save('lisa_gradient_y.png')
    Image.fromarray(gradient.astype(np.uint8)).save('lisa_gradient.png')
    Image.fromarray(binary_gradient.astype(np.uint8)).save('lisa_binary_gradient.png')




    image = Image.open('im2.png')

    gray_image, gradient_x, gradient_y, gradient, binary_gradient = robert_operator(image)

    # Сохранение изображений
    gray_image.save('im2_gray_image.png')
    Image.fromarray(gradient_x.astype(np.uint8)).save('im2_gradient_x.png')
    Image.fromarray(gradient_y.astype(np.uint8)).save('im2_gradient_y.png')
    Image.fromarray(gradient.astype(np.uint8)).save('im2_gradient.png')
    Image.fromarray(binary_gradient.astype(np.uint8)).save('im2_binary_gradient.png')



    image = Image.open('uzu.png')

    gray_image, gradient_x, gradient_y, gradient, binary_gradient = robert_operator(image)

    # Сохранение изображений
    gray_image.save('uzu_gray_image.png')
    Image.fromarray(gradient_x.astype(np.uint8)).save('uzu_gradient_x.png')
    Image.fromarray(gradient_y.astype(np.uint8)).save('uzu_gradient_y.png')
    Image.fromarray(gradient.astype(np.uint8)).save('uzu_gradient.png')
    Image.fromarray(binary_gradient.astype(np.uint8)).save('uzu_binary_gradient.png')

    binary_gradient_50 = binarize(gradient, 50)
    Image.fromarray(binary_gradient_50.astype(np.uint8)).save('uzu_binary_gradient_50.png')

image = Image.open('uzu.png')

gray_image, gradient_x, gradient_y, gradient, binary_gradient = robert_operator(image)

defbinary_gradient_100 = binarize(gradient, 100)
Image.fromarray(binary_gradient_100.astype(np.uint8)).save('uzu_binary_gradient_100.png')