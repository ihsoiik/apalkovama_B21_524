# -*- coding: utf-8 -*-
"""лаба7.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1x6NNWbkvA-d1RI85OBPvU94TZcuapzDj
"""

import pandas as pd
import numpy as np
from PIL import Image
#from features import FeatureImage
import csv
from math import sqrt
from google.colab import files

def dist(vector1, vector2):
    assert len(vector1) == len(vector2)
    sum_square_diff = 0

    for coord1, coord2 in zip(vector1, vector2):
        sum_square_diff += (coord1 - coord2) ** 2
    return sum_square_diff

def levenstein_distance(profile1, profile2):
    M = profile1.shape[0]
    N = profile2.shape[0]
    D = np.zeros((M + 1, N + 1))
    for j in range(1, N + 1):
        D[0, j] = D[0, j - 1] + 1
    for i in range(1, M + 1):
        D[i, 0] = D[i - 1, 0] + 1
        for j in range(1, N + 1):
            D[i, j] = min(
                D[i - 1, j] + 1,
                D[i, j - 1] + 1,
                D[i - 1, j - 1] + abs(profile1[i - 1] - profile2[j - 1])
            )
    return D[M, N]

def proximity(vector1, vector2):
    return 1 / (1 + dist(vector1, vector2))

feature_names = ['relative_' + name for name in
                 ['weight_I', 'weight_II', 'weight_III', 'weight_IV', 'center_x', 'center_y', 'inertia_x', 'inertia_y']]
target = 'ENGEVEZEKUŞÜMITTIRKALBIMIZDEHIÇSUSMAZ'
symbols = "ABCÇDEFGĞHIİJKLMNOÖPRSŞTÜVYZ"

import numpy as np
from os import path
from PIL import Image
import pandas as pd
from functools import cache
from itertools import product

symbols = "ABCÇDEFGĞHIİJKLMNOÖPRSŞTÜVYZ"
font_size = 52
font_path = './arial.ttf'


class FeatureImage:
    def __init__(self, img: Image, invert=True):
        if invert:
            self.img = 1 - np.array(img)
        else:
            self.img = np.array(img)

    @property
    def shape(self):
        return self.img.shape

    def __getitem__(self, key):
        return self.img[key]

    @cache
    def line_by_line_moment(self, p: int, q: int, start_x=None,
                            stop_x=None, start_y=None, stop_y=None) -> int:
        if start_x is None:
            start_x = 0
        if stop_x is None:
            stop_x = self.shape[0]
        if start_y is None:
            start_y = 0
        if stop_y is None:
            stop_y = self.shape[1]

        moment = 0

        for x in range(start_x, stop_x):
            for y in range(start_y, stop_y):
                moment += x ** p * y ** q * self[x, y]

        return moment

    def weight(self) -> int:
        return self.line_by_line_moment(0, 0)

    def area(self) -> int:
        return self.shape[0] * self.shape[1]

    def relative_weight(self) -> float:
        # print(self.weight())
        # print(self.shape)
        return self.weight() / self.area()

    def weight_I(self) -> int:
        hight = self.shape[0] // 2
        len = self.shape[1] // 2
        return self.line_by_line_moment(0, 0, start_x=0, stop_x=hight,
                                        start_y=0, stop_y=len)

    def relative_weight_I(self) -> float:
        area = self.area() // 4
        return self.weight_I() / area

    def weight_II(self) -> int:
        hight = self.shape[0] // 2
        len = self.shape[1] // 2
        return self.line_by_line_moment(0, 0, start_x=0, stop_x=hight,
                                        start_y=len, stop_y=self.shape[1])

    def relative_weight_II(self) -> float:
        area = self.area() // 4
        return self.weight_II() / area

    def weight_III(self) -> int:
        hight = self.shape[0] // 2
        len = self.shape[1] // 2
        return self.line_by_line_moment(0, 0, start_x=hight,
                                        stop_x=self.shape[0],
                                        start_y=0, stop_y=len)

    def relative_weight_III(self) -> float:
        area = self.area() // 4
        return self.weight_III() / area

    def weight_IV(self) -> int:
        start = self.shape[0] // 2
        start_y = self.shape[1] // 2
        hight = self.shape[0]
        len = self.shape[1]
        return self.line_by_line_moment(0, 0, start_x=start, stop_x=hight,
                                        start_y=start_y, stop_y=len)

    def relative_weight_IV(self) -> float:
        area = self.area() // 4
        return self.weight_IV() / area

    def center(self, axis: int) -> float:
        if axis not in (0, 1):
            raise ValueError("Invalid axis")

        p = int(not axis)
        q = axis
        return self.line_by_line_moment(p, q) / self.weight()

    def relative_center(self, axis: int) -> float:
        normalization_factor = self.shape[axis] - 1
        return (self.center(axis) - 1) / normalization_factor

    @cache
    def central_moment(self, p, q):
        x_bar = self.center(0)
        y_bar = self.center(1)
        moment = 0

        for x in range(self.shape[0]):
            for y in range(self.shape[1]):
                moment += (x - x_bar) ** p * (y - y_bar) ** q * self[x, y]

        return moment

    def inertia(self, axis):
        if axis not in (0, 1):
            raise ValueError("Invalid axis")

        p = axis * 2
        q = (1 - axis) * 2
        return self.central_moment(p, q)

    def relative_inertia(self, axis):
        return self.inertia(axis) / self.weight() ** 2

    def profile(self, axis):
        return np.sum(self.img, axis=1 - axis), np.arange(start=1, stop=self.shape[axis] + 1).astype(int)

    def profile_norm(self, axis):
        return np.sum(self.img, axis=1 - axis) / self.shape[1 - axis]


def axis_name(axis):
    return 'y' * (1 - axis) + 'x' * axis


def join_names(*args):
    return '_'.join(filter(lambda string: string != '', args))


def join_names(*args):
    return '_'.join(filter(lambda string: string != '', args))


if __name__ == '__main__':
    # Calculate features
    df = pd.DataFrame()
    feature_images = {letter: FeatureImage(Image.open(f'/content/drive/MyDrive/аови/letters/{letter}.bmp')) for letter in symbols}
    df['letter'] = feature_images.keys()
    non_directed_features = ['weight_I', 'weight_II', 'weight_III',
                             'weight_IV', 'weight']
    features = ['center', 'inertia']
    relativities = ['', 'relative']
    directions = [0, 1]

    for feature, relativity in product(non_directed_features, relativities):
        name = join_names(relativity, feature)
        df[name] = list(map(lambda img: getattr(img, name)(),
                            feature_images.values()))

    for feature, relativity, axis in product(features, relativities,
                                             directions):
        name = join_names(relativity, feature)
        df[f'{name}_{axis_name(axis)}'] = list(map(lambda img:
                                                   getattr(img, name)(axis),
                                                   feature_images.values()))

if __name__ == '__main__':
    uploaded = files.upload()
    features = pd.read_csv('features.csv')
    sentence = ""
    results = []

    for i in range(len(target)):
        symbol = FeatureImage(Image.open(f'/content/drive/MyDrive/аови/segmented/{i}.png'), invert=True)
        feature_vector = [
            symbol.relative_weight_I(),
            symbol.relative_weight_II(),
            symbol.relative_weight_III(),
            symbol.relative_weight_IV(),
            symbol.relative_center(1),
            symbol.relative_center(0),
            symbol.relative_inertia(1),
            symbol.relative_inertia(0)
        ]

        distances = features.apply(
            lambda feature_symbol: dist(feature_symbol[feature_names], feature_vector), axis=1
        )

        proximities = distances.apply(
            lambda distance: 1 - distance / distances.max()
        )

        feature_images = {letter: FeatureImage(Image.open(f"/content/drive/MyDrive/аови/letters/{letter}.bmp")) for i, letter in enumerate(symbols)}
        proximities = pd.concat([features.letter, proximities], axis=1)
        proximities.columns = ['letter', 'proximity']
        proximities = proximities.sort_values('proximity', ascending=False)
        proximities = proximities.reset_index(drop=True)

        delta = 0.9
        potential_letters = proximities[proximities.proximity > delta]
        if len(potential_letters) == 0:
            continue
        proximities['x_profile_distance'] = potential_letters.apply(
            lambda potential_symbol:
            levenstein_distance(symbol.profile_norm(0), feature_images[potential_symbol.letter].profile_norm(0)),
            axis=1
        )

        proximities['y_profile_distance'] = potential_letters.apply(
            lambda potential_symbol:
            levenstein_distance(symbol.profile_norm(1), feature_images[potential_symbol.letter].profile_norm(1)),
            axis=1
        )

        potential_letters = proximities[proximities.proximity > delta]
        proximities['profile_distance'] = potential_letters.apply(
            lambda potential_symbol:
            np.sqrt(potential_symbol.x_profile_distance ** 2 + potential_symbol.y_profile_distance ** 2),
            axis=1
        )

        potential_letters = proximities[proximities.proximity > delta]
        proximities['profile_proximity'] = potential_letters.apply(
            lambda potential_symbol:
            1 - potential_symbol.profile_distance / potential_letters.profile_distance.max(),
            axis=1
        )

        potential_letters = proximities[proximities.proximity > delta]
        proximities = proximities.sort_values(['profile_proximity', 'proximity'], ascending=False)
        proximities = proximities.reset_index(drop=True)
        results.append(proximities.apply(
            lambda guessed_letter:
            (guessed_letter['letter'], guessed_letter['proximity'])
            , axis=1
        ))

        sentence += proximities['letter'][0]
        print(sentence)

    res = pd.DataFrame(results)
    res.to_csv('result.csv')

    correct_guesses = 0
    for i, (expected, actual) in enumerate(zip(target, sentence)):
        correct_guesses += (expected == actual)
        if expected != actual:
            print("Mistake: index =", str(i) + ", expected:", expected, "but got", actual)

    print(correct_guesses)
    print('Accuracy:', correct_guesses / 37)